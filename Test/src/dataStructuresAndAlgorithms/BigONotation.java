package dataStructuresAndAlgorithms;

// This class is a placeholder for Big O Notation concepts and examples.
public class BigONotation {

	/*
	 * How Code Slows as Data Grows
	 * 1. Describes the performance of an algorithm as the amount of data increases.
	 * 2. Machine independent (# of steps to completion)
	 * 3. Ignore smaller operations. eg O(n +1 ) is O(n)
	 * 
	 * example
	 * o(1) - constant time
	 * o(n) - linear time
	 * o(n^2) - quadratic time
	 * o(log n) - logarithmic time
	 * o(n log n) - linearithmic time
	 * o(2^n) - exponential time
	 * o(n!) - factorial time
	 * 
	 * Common Big O Notations
	 * o(1) - Constant Time
	 * 	* An algorithm is said to have constant time complexity if the time taken to complete	
	 * the task remains the same regardless of the size of the input data set.
	 * => Random access of an element in an array.
	 * => inserting or deleting an element at the beginning of a linked list.
	 * 
	 * O(log n) - Logarithmic Time
	 * 
	 * => Binary Search
	 * 
	 * O(n) - Linear Time
	 * => Looping through elements in an array
	 * => searching through a linked list
	 * 
	 * O(n log n) - Linearithmic Time
	 * =>Quick Sort
	 * => Merge Sort
	 * => Heap Sort
	 * 
	 * O(n^2) - Quadratic Time
	 * => Bubble Sort
	 * => Insertion Sort
	 * => Selection Sort
	 * 
	 * O(2^n) - Exponential Time
	 * => Solving the Tower of Hanoi problem
	 * => Generating all subsets of a set
	 * 
	 * O(n!) - Factorial Time
	 * => Solving the Traveling Salesman Problem using brute-force approach
	 * => Generating all permutations of a set
	 * 
	 * 
.	 */
}
